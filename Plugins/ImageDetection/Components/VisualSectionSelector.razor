@using ImageDetection.Services
@using ImageDetection.Models
@using MultiShock.PluginSdk.Components
@inject ScreenCaptureService ScreenCapture
@inject IJSRuntime JS
@implements IDisposable

@if (IsVisible && _screenshot != null)
{
    <div class="fixed inset-0 z-[1000] flex items-center justify-center p-5">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" @onclick="Close"></div>
        
        <div class="relative bg-zinc-800 border border-zinc-700 rounded-xl max-w-[90vw] max-h-[90vh] flex flex-col overflow-hidden shadow-2xl">
            <div class="flex justify-between items-center px-5 py-4 border-b border-zinc-700 bg-zinc-800">
                <div>
                    <h4 class="m-0 text-lg font-semibold">Visual Section Selector</h4>
                    <span class="block text-xs text-zinc-400 mt-1">@_actualResolution</span>
                </div>
                <div class="flex items-center gap-3">
                    <span class="text-xs px-3 py-1 rounded-full bg-blue-500/20 text-blue-400 font-medium">@GetEnabledCount() of 9 sections enabled</span>
                    <button class="bg-transparent border-none text-zinc-400 cursor-pointer w-8 h-8 flex items-center justify-center rounded-md hover:bg-white/10 hover:text-zinc-100 transition-all text-xl" 
                            @onclick="Close">&times;</button>
                </div>
            </div>
            
            <div class="flex-1 overflow-auto p-5 flex flex-col gap-4">
                <div class="flex gap-2 justify-center">
                    <span class="text-xs px-2.5 py-1 rounded-full bg-zinc-700/50 text-zinc-400">Monitor @MonitorIndex</span>
                    <span class="text-xs px-2.5 py-1 rounded-full bg-zinc-700/50 text-zinc-400">@(_isScaled ? "Scaled for display" : "Actual size")</span>
                </div>
                
                <div class="relative inline-block self-center rounded-lg overflow-hidden shadow-lg" @ref="_containerRef">
                    <img src="@GetImageDataUrl()" alt="Screen preview" class="block max-w-full max-h-[60vh] object-contain" />

                    <div class="absolute inset-0 grid grid-cols-3 grid-rows-3">
                        @for (int row = 0; row < 3; row++)
                        {
                            @for (int col = 0; col < 3; col++)
                            {
                                var index = row * 3 + col;
                                <div class="relative border-2 border-white/30 cursor-pointer transition-all flex flex-col items-center justify-center hover:border-white/80 hover:scale-[0.98] @GetCellClass(index)" 
                                     style="grid-row: @(row + 1); grid-column: @(col + 1);"
                                     @onclick="() => ToggleSection(index)">
                                    <span class="text-2xl font-bold text-white drop-shadow-lg">@(index + 1)</span>
                                    <div class="absolute top-2 right-2 w-3 h-3 rounded-full @(_sectionStates[index] ? "bg-green-500 shadow-[0_0_8px_rgba(34,197,94,1)]" : "bg-red-500 shadow-[0_0_8px_rgba(239,68,68,1)]")"></div>
                                </div>
                            }
                        }
                    </div>
                </div>
                
                <div class="flex gap-2 justify-center flex-wrap">
                    <Button Text="Enable All" Size="sm" Variant="secondary" OnClick="SelectAll" />
                    <Button Text="Disable All" Size="sm" Variant="secondary" OnClick="SelectNone" />
                    <Button Text="Invert" Size="sm" Variant="ghost" OnClick="Invert" />
                    <Button Text="Refresh Screenshot" Size="sm" Variant="primary" OnClick="RefreshScreenshot" />
                </div>
            </div>
            
            <div class="flex justify-between items-center px-5 py-4 border-t border-zinc-700 bg-zinc-800 gap-4">
                <p class="text-sm text-zinc-400 m-0">
                    Click on the image sections to toggle them on/off. 
                    The grid matches the detection resolution exactly.
                    Green = enabled, Red = disabled.
                </p>
                <Button Text="Done" Size="sm" Variant="success" OnClick="Close" />
            </div>
        </div>
    </div>
}

@code {
    private ElementReference _containerRef;
    private Emgu.CV.Mat? _screenshot;
    private bool[] _sectionStates = new bool[9];
    private bool _isCapturing = false;
    private string _actualResolution = "";
    private bool _isScaled = false;
    private const int MaxDisplayWidth = 1200;
    private const int MaxDisplayHeight = 800;

    [Parameter]
    public bool IsVisible { get; set; }

    [Parameter]
    public int MonitorIndex { get; set; } = 1;

    [Parameter]
    public EventCallback<bool[]> OnSelectionChanged { get; set; }

    [Parameter]
    public EventCallback OnClose { get; set; }

    [Parameter]
    public bool[]? SectionStates { get; set; }

    protected override void OnParametersSet()
    {
        if (SectionStates?.Length == 9)
        {
            _sectionStates = SectionStates.ToArray();
        }
        else
        {
            _sectionStates = Enumerable.Repeat(true, 9).ToArray();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && IsVisible)
        {
            await CaptureScreenshot();
        }
        else if (IsVisible && _screenshot == null && !_isCapturing)
        {
            await CaptureScreenshot();
        }
    }

    private async Task CaptureScreenshot()
    {
        if (_isCapturing) return;
        
        _isCapturing = true;
        try
        {
            await Task.Run(() =>
            {
                _screenshot = ScreenCapture.CaptureMonitor(MonitorIndex);

                _actualResolution = $"{_screenshot.Width}x{_screenshot.Height}";

                _isScaled = _screenshot.Width > MaxDisplayWidth || _screenshot.Height > MaxDisplayHeight;
            });
            StateHasChanged();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to capture screenshot: {ex.Message}");
            _actualResolution = "Capture failed";
        }
        finally
        {
            _isCapturing = false;
        }
    }

    private async Task RefreshScreenshot()
    {
        _screenshot?.Dispose();
        _screenshot = null;
        await CaptureScreenshot();
    }

    private string GetImageDataUrl()
    {
        if (_screenshot == null) return "";
        
        try
        {
            using var resized = new Emgu.CV.Mat();
            
            double scale = Math.Min(
                (double)MaxDisplayWidth / _screenshot.Width,
                (double)MaxDisplayHeight / _screenshot.Height
            );
            
            if (scale < 1.0)
            {
                var newWidth = (int)(_screenshot.Width * scale);
                var newHeight = (int)(_screenshot.Height * scale);
                Emgu.CV.CvInvoke.Resize(_screenshot, resized, new System.Drawing.Size(newWidth, newHeight), 
                    interpolation: Emgu.CV.CvEnum.Inter.Linear);
            }
            else
            {
                _screenshot.CopyTo(resized);
            }

            var bytes = resized.ToImage<Emgu.CV.Structure.Bgra, byte>().ToJpegData(85);
            var base64 = Convert.ToBase64String(bytes);
            return $"data:image/jpeg;base64,{base64}";
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Failed to convert screenshot: {ex.Message}");
            return "";
        }
    }

    private string GetCellClass(int index) => _sectionStates[index] 
        ? "bg-green-500/25 border-green-500 hover:bg-green-500/35" 
        : "bg-red-500/25 border-red-500 hover:bg-red-500/35";

    private void ToggleSection(int index)
    {
        _sectionStates[index] = !_sectionStates[index];
        StateHasChanged();
        OnSelectionChanged.InvokeAsync(_sectionStates);
    }

    private void SelectAll()
    {
        for (int i = 0; i < 9; i++) _sectionStates[i] = true;
        StateHasChanged();
        OnSelectionChanged.InvokeAsync(_sectionStates);
    }

    private void SelectNone()
    {
        for (int i = 0; i < 9; i++) _sectionStates[i] = false;
        StateHasChanged();
        OnSelectionChanged.InvokeAsync(_sectionStates);
    }

    private void Invert()
    {
        for (int i = 0; i < 9; i++) _sectionStates[i] = !_sectionStates[i];
        StateHasChanged();
        OnSelectionChanged.InvokeAsync(_sectionStates);
    }

    private async Task Close()
    {
        await OnClose.InvokeAsync();
    }

    private int GetEnabledCount() => _sectionStates.Count(s => s);

    public void Dispose()
    {
        _screenshot?.Dispose();
    }
}
